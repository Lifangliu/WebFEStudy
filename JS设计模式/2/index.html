<!DOCTYPE html>
<html lang="zh_CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>12.高级前端面试题</title>
    <link rel="stylesheet" href="./static/bootstrap/css/bootstrap.min.css">
    <style type="text/css">
    body {
        font-family: "微软雅黑";
        padding-top: 70px;
    }
    p {
        text-indent: 2em;
        /*em是相对单位，2em即现在一个字大小的两倍*/
    }
    h3{
        font-weight: 100;
    }
    </style>
</head>

<body>
    <nav class="navbar navbar-fixed-top navbar-dark bg-primary">
        <a class="navbar-brand" href="#">大前端面试题</a>
        <ul class="nav navbar-nav">
            <li class="nav-item active">
                <a class="nav-link" href="#html">
                    HTML篇
                    <span class="sr-only">(current)</span>
                </a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="#css">CSS篇</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="#js">JavaScript篇</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="#chuchujie">楚楚街JS研发经理</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="#antgroup">蚂蚁金服-资深H5前端开发工程师</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="#alimama">阿里妈妈-前端开发专家</a>
            </li>
        </ul>
        <form class="form-inline navbar-form pull-right">
            <input class="form-control" type="text" placeholder="请输入关键词">
            <button class="btn btn-secondary-outline" type="submit">搜索</button>
        </form>
    </nav>
    <div class="container">
        <div class="row">
            <div id="html" class="col-md-10 col-md-offset-1">
                <h3>HTML篇</h3>
                <hr>
                <h5>1.你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?</h5>
                <hr>
                答案：
                <br>
                <ol>
                    <li>IE: trident内核</li>
                    <li>Firefox：gecko内核</li>
                    <li>Safari:webkit内核</li>
                    <li>Opera:以前是presto内核，Opera现已改用Google Chrome的Blink内核</li>
                    <li>
                        Chrome:Blink(基于webkit，
                        <a href="http://baike.baidu.com/view/1369399.htm#1_5" target="_blank">Google与Opera Software共同开发</a>
                        )
                    </li>
                </ol>
                <h5>2.每个HTML文件里开头都有个很重要的东西，Doctype，知道这是干什么的吗？</h5>
                <hr>
                答案：
                <p>
                    &lt;!DOCTYPE&gt; 声明位于文档中的最前面的位置，处于 &lt;html&gt; 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。（重点：告诉浏览器按照何种规范解析页面）
                </p>
                <h5>3.Quirks模式是什么？它和Standards模式有什么区别</h5>
                <hr>
                答案：
                <br>
                <p>
                    从IE6开始，引入了Standards模式，标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。
                </p>
                <p>
                    在IE6之前CSS还不够成熟，所以IE5等之前的浏览器对CSS的支持很差， IE6将对CSS提供更好的支持，然而这时的问题就来了，因为有很多页面是基于旧的布局方式写的，而如果IE6 支持CSS则将令这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲染机制呢？
                </p>
                <p>
                    在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。遇到这种问题时的一个常见做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数 不为真时，就使用旧功能，这样就能不破坏原有的程序，又提供新功能。IE6也是类似这样做的，它将DTD当成了这个“参数”，因为以前的页面大家都不会去写DTD，所以IE6就假定 如果写了DTD，就意味着这个页面将采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是Quirks模式（怪癖模式，诡异模式，怪异模式）。
                </p>
                区别：
                <p>总体会有布局、样式解析和脚本执行三个方面的区别。</p>
                <p>
                    盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在Quirks 模式下，IE的宽度和高度还包含了padding和border。
                </p>
                <p class="text-center">
                    <img src="./static/images/box.png"></p>
                <p>
                    设置行内元素的高宽：在Standards模式下，给&lt;span&gt;等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。
                </p>
                <p>
                    设置百分比的高度：在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的用margin:0 auto设置水平居中：使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效。
                </p>
                <p>（还有很多，答出什么不重要，关键是看他答出的这些是不是自己经验遇到的，还是说都是看文章看的，甚至完全不知道。）</p>
                <h5>4.div+css的布局较table布局有什么优点？</h5>
                <hr>
                <p>
                    改版的时候更方便 只要改css文件。 页面加载速度更快、结构化清晰、页面显示简洁。 表现与结构相分离。 易于优化（seo）搜索引擎更友好，排名更容易靠前。
                </p>
                <h5>5.a：img的alt与title有何异同？b：strong与em的异同？</h5>
                <hr>
                答案：
                <br>
                a:
                <br>
                <p>
                    alt(alt text):为不能显示图像、窗体或applets的用户代理（UA），alt属性用来指定替换文字。替换文字的语言由lang属性指定。(在IE浏览器下会在没有title时把alt当成 tool tip显示) title(tool tip):该属性为设置该属性的元素提供建议性的信息。
                </p>
                b:
                <br>
                <p>strong:粗体强调标签，强调，表示内容的重要性</p>
                <p>em:斜体强调标签，更强烈强调，表示内容的强调点</p>
                <h5>6.你能描述一下渐进增强和优雅降级之间的不同吗?</h5>
                <hr>
                <p>
                    渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。
                </p>
                “优雅降级”观点
                <br>
                <br>
                <p>
                    “优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。
                </p>
                <p>
                    在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。
                </p>
                “渐进增强”观点
                <br>
                <br>
                “渐进增强”观点则认为应关注于内容本身。
                <br>
                <br>
                <p>
                    内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。
                </p>
                <p>
                    那么问题来了。现在产品经理看到IE6,7,8网页效果相对高版本现代浏览器少了很多圆角，阴影（CSS3），要求兼容（使用图片背景，放弃CSS3），你会如何说服他？
                </p>
                （自由发挥）
                <h5>7.为什么利用多个域名来存储网站资源会更有效？</h5>
                <hr>
                <ul>
                    <li>CDN缓存更方便</li>
                    <li>突破浏览器并发限制</li>
                    <li>节约cookie带宽</li>
                    <li>节约主域名的连接数，优化页面响应速度</li>
                    <li>防止不必要的安全问题</li>
                </ul>
                <h5>8.请谈一下你对网页标准和标准制定机构重要性的理解。</h5>
                <hr>
                <p>
                    （无标准答案）网页标准和标准制定机构都是为了能让web发展的更‘健康’，开发者遵循统一的标准，降低开发难度，开发成本，SEO也会更好做，也不会因为滥用代码导致各种BUG、安全问题，最终提高网站易用性。
                </p>
                <h5>9.请描述一下cookies，sessionStorage和localStorage的区别？</h5>
                <hr>
                <p>
                    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
                </p>
                web storage和cookie的区别
                <br>
                <p>
                    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。
                </p>
                <p>
                    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。
                </p>
                <h5>10.简述一下src与href的区别。</h5>
                答案：
                <br>
                <p>src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。</p>
                <p>
                    src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。
                </p>
                &lt;script src ="js.js"&gt;&lt;/script&gt;
                <p>
                    当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。
                </p>
                <p>
                    href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加
                </p>
                &lt;link href="common.css" rel="stylesheet"/&gt;
                <br>
                <p>
                    那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式。
                </p>
                <h5>11.知道的网页制作会用到的图片格式有哪些？</h5>
                <hr>
                答案：
                <br>
                png-8，png-24，jpeg，gif，svg。
                <br>
                <br>
                但是上面的那些都不是面试官想要的最后答案。面试官希望听到是Webp。（是否有关注新技术，新鲜事物）
                <br>
                <p>
                    科普一下Webp：WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。
                </p>
                在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%
                <br>
                <br>
                <h5>12.知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？</h5>
                <hr>
                答案：
                <br>
                <p>
                    微格式（Microformats）是一种让机器可读的语义化XHTML词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式。
                </p>
                <p>优点：将智能数据添加到网页上，让网站内容在搜索引擎结果界面可以显示额外的提示。（应用范例：豆瓣，有兴趣自行google）</p>
                <h5>
                    13.在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？
                </h5>
                <hr>
                答案：dns缓存，cdn缓存，浏览器缓存，服务器缓存。
                <br>
                <br>
                <h5>14.一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。</h5>
                <hr>
                <p>
                    图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。 如果图片为css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。 如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。
                </p>
                <h5>15.你如何理解HTML结构的语义化？</h5>
                <hr>
                <p>
                    去掉或样式丢失的时候能让页面呈现清晰的结构： html本身是没有表现的，我们看到例如 &lt;h1&gt;是粗体，字体大小2em，加粗；&lt;strong&gt;是加粗的，不要认为这是html的表现，这些其实html默认的css样式在起作用，所以去掉或样式丢失的时候能让页面呈现清晰的结构不是语义化的HTML结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达html的语义，可以说浏览器的默认样式和语义化的HTML结构是不可分割的。
                </p>
                <p>
                    屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页. 例如,如果你使用的含语义的标记,屏幕阅读器就会“逐个拼出”你的单词,而不是试着去对它完整发音.
                </p>
                <p>
                    PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱） 使用语义标记可以确保这些设备以一种有意义的方式来渲染网页.理想情况下,观看设备的任务是符合设备本身的条件来渲染网页.
                </p>
                <p>
                    语义标记为设备提供了所需的相关信息,就省去了你自己去考虑所有可能的显示情况（包括现有的或者将来新的设备）.例如,一部手机可以选择使一段标记了标题的文字以粗体显示.而掌上电脑可能会以比较大的字体来显示.无论哪种方式一旦你对文本标记为标题,您就可以确信读取设备将根据其自身的条件来合适地显示页面.
                </p>
                <p>
                    搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重 过去你可能还没有考虑搜索引擎的爬虫也是网站的“访客”,但现在它们他们实际上是极其宝贵的用户.没有他们的话,搜索引擎将无法索引你的网站,然后一般用户将很难过来访问.
                </p>
                <p>
                    你的页面是否对爬虫容易理解非常重要,因为爬虫很大程度上会忽略用于表现的标记,而只注重语义标记. 因此,如果页面文件的标题被标记,而不是,那么这个页面在搜索结果的位置可能会比较靠后.除了提升易用性外,语义标记有利于正确使用CSS和JavaScript,因为其本身提供了许多“钩钩”来应用页面的样式与行为.
                </p>
                <p>SEO主要还是靠你网站的内容和外部链接的。</p>
                <p>
                    便于团队开发和维护 W3C给我们定了一个很好的标准，在团队中大家都遵循这个标准，可以减少很多差异化的东西，方便开发和维护，提高开发效率，甚至实现模块化开发。
                </p>
                <h5>16.谈谈以前端角度出发做好SEO需要考虑什么？</h5>
                <hr>
                <p>
                    了解搜索引擎如何抓取网页和如何索引网页 你需要知道一些搜索引擎的基本工作原理，各个搜索引擎之间的区别，搜索机器人（SE robot 或叫 web crawler）如何进行工作，搜索引擎如何对搜索结果进行排序等等。
                </p>
                Meta标签优化
                <p>
                    主要包括主题（Title)，网站描述(Description)，和关键词（Keywords）。还有一些其它的隐藏文字比如Author（作者），Category（目录），Language（编码语种）等。
                </p>
                如何选取关键词并在网页中放置关键词
                <p>
                    搜索就得用关键词。关键词分析和选择是SEO最重要的工作之一。首先要给网站确定主关键词（一般在5个上下），然后针对这些关键词进行优化，包括关键词密度（Density），相关度（Relavancy），突出性（Prominency）等等。
                </p>
                了解主要的搜索引擎
                <p>
                    虽然搜索引擎有很多，但是对网站流量起决定作用的就那么几个。比如英文的主要有Google，Yahoo，Bing等；中文的有百度，搜狗，有道等。不同的搜索引擎对页面的抓取和索引、排序的规则都不一样。还要了解各搜索门户和搜索引擎之间的关系，比如AOL网页搜索用的是Google的搜索技术，MSN用的是Bing的技术。
                </p>
                主要的互联网目录
                <p>
                    Open Directory自身不是搜索引擎，而是一个大型的网站目录，他和搜索引擎的主要区别是网站内容的收集方式不同。目录是人工编辑的，主要收录网站主页；搜索引擎是自动收集的，除了主页外还抓取大量的内容页面。
                </p>
                按点击付费的搜索引擎
                <p>
                    搜索引擎也需要生存，随着互联网商务的越来越成熟，收费的搜索引擎也开始大行其道。最典型的有Overture和百度，当然也包括Google的广告项目Google Adwords。越来越多的人通过搜索引擎的点击广告来定位商业网站，这里面也大有优化和排名的学问，你得学会用最少的广告投入获得最多的点击。
                </p>
                搜索引擎登录
                <p>
                    网站做完了以后，别躺在那里等着客人从天而降。要让别人找到你，最简单的办法就是将网站提交（submit）到搜索引擎。如果你的是商业网站，主要的搜索引擎和目录都会要求你付费来获得收录（比如Yahoo要299美元），但是好消息是（至少到目前为止）最大的搜索引擎Google目前还是免费，而且它主宰着60％以上的搜索市场。
                </p>
                链接交换和链接广泛度（Link Popularity）
                <p>
                    网页内容都是以超文本（Hypertext）的方式来互相链接的，网站之间也是如此。除了搜索引擎以外，人们也每天通过不同网站之间的链接来Surfing（“冲浪”）。其它网站到你的网站的链接越多，你也就会获得更多的访问量。更重要的是，你的网站的外部链接数越多，会被搜索引擎认为它的重要性越大，从而给你更高的排名。合理的标签使用
                </p>
            </div>
            <div id="css" class="col-md-10 col-md-offset-1">
                <h3>CSS篇</h3>
                <hr>
                <h5>1.有哪项方式可以对一个DOM设置它的CSS样式？</h5>
                <hr>
                <p>
                    外部样式表，引入一个外部css文件 内部样式表，将css代码放在 &lt;head&gt; 标签内部 内联样式，将css样式直接定义在 HTML 元素内部
                </p>
                <h5>2.CSS都有哪些选择器？</h5>
                <hr>
                派生选择器（用HTML标签申明）
                <br>
                id选择器（用DOM的ID申明）
                <br>
                类选择器（用一个样式类名申明）
                <br>
                属性选择器（用DOM的属性申明，属于CSS2，IE6不支持，不常用，不知道就算了）
                <br>
                除了前3种基本选择器，还有一些扩展选择器，包括
                <br>
                后代选择器（利用空格间隔，比如div .a{ }）
                <br>
                群组选择器（利用逗号间隔，比如p,div,#a{ }）
                <br>
                那么问题来了，CSS选择器的优先级是怎么样定义的？
                <br>
                <br>
                基本原则：
                <br>
                一般而言，选择器越特殊，它的优先级越高。也就是选择器指向的越准确，它的优先级就越高。
                <br>
                复杂的计算方法：
                <br>
                用1表示派生选择器的优先级
                <br>
                用10表示类选择器的优先级
                <br>
                用100标示ID选择器的优先级
                <br>
                div.test1 .span var 优先级 1+10 +10 +1
                <br>
                span#xxx .songs li 优先级1+100 + 10 + 1
                <br>
                #xxx li 优先级 100 +1
                <br>
                那么问题来了，看下列代码，&lt;p&gt;标签内的文字是什么颜色的？
                <br>
                <br>
                <pre>
&lt;style&gt;
.classA{ color:blue;}
.classB{ color:red;}
&lt;/style&gt;
&lt;body&gt;
&lt;p class='classB classA'&gt; 123 &lt;/p&gt;
&lt;/body&gt;
                </pre>
                答案：red。与样式定义在文件中的先后顺序有关，即是后面的覆盖前面的，与在 &lt;p class=’classB classA’&gt;中的先后关系无关。
                <br>
                <br>
                <h5>3.CSS中可以通过哪些属性定义，使得一个DOM元素不显示在浏览器可视范围内？</h5>
                <hr>
                最基本的：
                <br>
                设置display属性为none，或者设置visibility属性为hidden
                <br>
                <br>
                技巧性：
                <br>
                设置宽高为0，设置透明度为0，设置z-index位置在-1000
                <br>
                <br>
                <h5>4.超链接访问过后hover样式就不出现的问题是什么？如何解决？</h5>
                <hr>
                答案：被点击访问过的超链接样式不在具有hover和active了,解决方法是改变CSS属性的排列顺序: L-V-H-A（link,visited,hover,active）
                <br>
                <br>
                <h5>5.什么是Css Hack？ie6,7,8的hack分别是什么？</h5>
                <hr>
                答案：针对不同的浏览器写不同的CSS code的过程，就是CSS hack。
                <br>
                示例如下：
                <br>
                <pre>
#test {   
        width:300px;   
        height:300px;   
        background-color:blue;/*firefox*/
        background-color:red\9;/*all ie*/
        background-color:yellow;/*ie8*/      
        +background-color:pink;/*ie7*/      
        _background-color:orange;/*ie6*/       
    }  
    :root #test { background-color:purple\9; }  /*ie9*/
    @media all and (min-width:0px){ #test {background-color:black;} }  /*opera*/
    @media screen and (-webkit-min-device-pixel-ratio:0){ #test {background-color:gray;} }       
    /*chrome and safari*/
    </pre>
                <h5>6.请用Css写一个简单的幻灯片效果页面</h5>
                <hr>
                答案：知道是要用css3。使用animation动画实现一个简单的幻灯片效果。
                <br>
                <pre>
/**HTML**/
div.ani        
/**css**/
.ani{
  width:480px;
  height:320px;
  margin:50px auto;
  overflow: hidden;
  box-shadow:0 0 5px rgba(0,0,0,1);
  background-size: cover;
  background-position: center;
  -webkit-animation-name: "loops";
  -webkit-animation-duration: 20s;
  -webkit-animation-iteration-count: infinite;
}
@-webkit-keyframes "loops" {
    0% {
        background:url(http://d.hiphotos.baidu.com/image/w%3D400/sign=c01e6adca964034f0fcdc3069fc27980/e824b899a9014c08e5e38ca4087b02087af4f4d3.jpg) no-repeat;             
    }
    25% {
        background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=edee1572e9f81a4c2632edc9e72b6029/30adcbef76094b364d72bceba1cc7cd98c109dd0.jpg) no-repeat;
    }
    50% {
        background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=937dace2552c11dfded1be2353266255/d8f9d72a6059252d258e7605369b033b5bb5b912.jpg) no-repeat;
    }
    75% {
        background:url(http://g.hiphotos.baidu.com/image/w%3D400/sign=7d37500b8544ebf86d71653fe9f9d736/0df431adcbef76095d61f0972cdda3cc7cd99e4b.jpg) no-repeat;
    }
    100% {
        background:url(http://c.hiphotos.baidu.com/image/w%3D400/sign=cfb239ceb0fb43161a1f7b7a10a54642/3b87e950352ac65ce2e73f76f9f2b21192138ad1.jpg) no-repeat;
    }
}
</pre>
                <br>
                <h5>7.行内元素和块级元素的具体区别是什么？行内元素的padding和margin可设置吗？</h5>
                <hr>
                块级元素(block)特性：
                <br>
                <p>
                    总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示; 宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制; 内联元素(inline)特性：
                </p>
                和相邻的内联元素在同一行;
                <br>
                <p>
                    宽度(width)、高度(height)、内边距的top/bottom(padding-top/padding-bottom)和外边距的top/bottom(margin-top/margin-bottom)都不可改变（也就是padding和margin的left和right是可以设置的），就是里面文字或图片的大小。 那么问题来了，浏览器还有默认的天生inline-block元素（拥有内在尺寸，可设置高宽，但不会自动换行），有哪些？
                </p>
                答案：&lt;input&gt; 、&lt;img&gt; 、&lt;button&gt; 、&lt;texterea&gt; 、&lt;label&gt;。
                <br>
                <h5>8.什么是外边距重叠？重叠的结果是什么？</h5>
                <hr>
                答案：
                <br>
                外边距重叠就是margin-collapse。
                <br>
                <p>
                    在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。
                </p>
                折叠结果遵循下列计算规则：
                <br>
                两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。
                <br>
                两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。
                <br>
                两个外边距一正一负时，折叠结果是两者的相加的和。
                <br>
                <br>
                <h5>9.rgba()和opacity的透明效果有什么不同？</h5>
                <hr>
                答案：
                <br>
                <p>
                    rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度，而rgba()只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！）
                </p>
                <br>
                <h5>10.css中可以让文字在垂直和水平方向上重叠的两个属性是什么？</h5>
                <hr>
                答案：
                <br>
                垂直方向：line-height
                <br>
                水平方向：letter-spacing
                <br>
                那么问题来了，关于letter-spacing的妙用知道有哪些么？
                <br>
                答案:可以用于消除inline-block元素间的换行符空格间隙问题。
                <br>
                <br>
                <h5>11.如何垂直居中一个浮动元素？</h5>
                <hr>
                // 方法一：已知元素的高宽
                <br>
                <pre>
#div1{
    background-color:#6699FF;
    width:200px;
    height:200px;
 
    position: absolute;        //父元素需要相对定位
    top: 50%;
    left: 50%;
    margin-top:-100px ;   //二分之一的height，width
    margin-left: -100px;
    }
 
//方法二:未知元素的高宽
 
  #div1{
    width: 200px;
    height: 200px;
    background-color: #6699FF;
 
    margin:auto;
    position: absolute;        //父元素需要相对定位
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    }
那么问题来了，如何垂直居中一个&lt;img&gt;?（用更简便的方法。）

#container     //&lt;img&gt;的容器设置如下
{
    display:table-cell;
    text-align:center;
    vertical-align:middle;
}
    </pre>
                <h5>12.px和em的区别。</h5>
                <hr>
                <p>
                    px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。
                </p>
                浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。
                <br>
                <br>
                <h5>13.描述一个”reset”的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？</h5>
                <hr>
                <p>
                    重置样式非常多，凡是一个前端开发人员肯定有一个常用的重置CSS文件并知道如何使用它们。他们是盲目的在做还是知道为什么这么做呢？原因是不同的浏览器对一些元素有不同的默认样式，如果你不处理，在不同的浏览器下会存在必要的风险，或者更有戏剧性的性发生。
                </p>
                <p>
                    你可能会用Normalize来代替你的重置样式文件。它没有重置所有的样式风格，但仅提供了一套合理的默认样式值。既能让众多浏览器达到一致和合理，但又不扰乱其他的东西（如粗体的标题）。
                </p>
                <p>
                    在这一方面，无法做每一个复位重置。它也确实有些超过一个重置，它处理了你永远都不用考虑的怪癖，像HTML的audio元素不一致或line-height不一致。
                </p>
                <br>
                <h5>14.Sass、LESS是什么？大家为什么要使用他们？</h5>
                <hr>
                <br>
                他们是CSS预处理器。他是CSS上的一种抽象层。他们是一种特殊的语法/语言编译成CSS。
                <br>
                <br>
                <p>
                    例如Less是一种动态样式语言. 将CSS赋予了动态语言的特性，如变量，继承，运算， 函数. LESS 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可一在服务端运行 (借助 Node.js)。
                </p>
                为什么要使用它们？
                <br>
                <p>
                    结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对浏览器语法差异的重复处理，减少无意义的机械劳动。
                </p>
                <p>
                    可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。
                </p>
                <h5>15.display:none与visibility:hidden的区别是什么？</h5>
                <hr>
                <p>
                    display : 隐藏对应的元素但不挤占该元素原来的空间。 visibility: 隐藏对应的元素并且挤占该元素原来的空间。 即是，使用CSS display:none属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”;而使用visibility:hidden属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。
                </p>
            </div>
            <div id="js" class="col-md-10 col-md-offset-1">
                <h3>JavaScript篇</h3>
                <hr>
                <h5>1.回答以下代码，alert的值分别是多少？</h5>
                <pre>
    var a = 10;  
    function test() {  
        a = 100;  
        alert(a);  
        alert(this.a);  
        var a;  
        alert(a);  
    }  
    test();
                </pre>
                <hr>
                <p>答案是：100， 10， 100</p>
                <h5>2.回答以下代码，alert的值分别是多少？</h5>
                <pre>
    var a = 100;  
    function test(){  
        alert(a);  
        var a = 10;  
        alert(a);  
    }  
    test();    
                </pre>
                <hr>
                <p>答案是： undefined， 10</p>
                <h5>3.回答以下代码，alert的值分别是多少？</h5>
                <pre>
    var a = 100;    
    function test(){    
        alert(a);    
        a = 10;  //去掉了var 就变成定义了全局变量了  
        alert(a);    
    }    
    test();   
    alert(a); 
                </pre>
                <hr>
                <p>答案是：100， 10， 10</p>
                <h5>4.回答以下代码，console的值是多少？</h5>
                <pre>
    (function() {
       var a = b = 5;
    })();
    console.log(b);
                </pre>
                <hr>
                <p>
                    答案是：5。
                    <p>1.这里有两个变量声明，但 a 使用关键字var声明的。代表它是一个函数的局部变量。与此相反，b 变成了全局变量。</p>
                    <p>
                        2.没有使用严格模式 ('use strict';)。如果启用了严格模式，代码就会引发ReferenceError的错误：B没有定义（b is not defined）。
                    </p>
                </p>
                <h5>5.给字符串对象定义一个repeatify功能。当传入一个整数n时，它会返回重复n次字符串的结果。例如：？</h5>
                <pre>console.log('hello'.repeatify(3));</pre>
                <hr>
                <p>
                    <pre>
    String.prototype.repeatify = String.prototype.repeatify || function(times) {
       var str = '';
       for (var i = 0; i < times; i++) {
          str += this;
       }
       return str;
    };
                    </pre></p>
                <h5>6.执行这段代码，输出什么结果。？</h5>
                <pre>
    function test() {
       console.log(a);
       console.log(foo());
       var a = 1;
       function foo() {
          return 2;
       }
    }
    test();
                </pre>
                <hr>
                <p>
                    答案是：  undefined 和 2。原因是，变量和函数的声明都被提前了（移到了函数的顶部），但变量不分配任何值。因此，在打印变量的时候，它在函数中存在（它被声明了），但它仍然是undefined 。表示换句话说，上面的代码等同于以下内容：
                </p>
                <h5 id="chuchujie">7.跨域Ajax的几种方式？【楚楚街JS研发经理】</h5>
                <hr>
                <p> <b>同源策略</b>
                    <p>
                        在客户端编程语言中，如JavaScript和ActionScript，同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义。同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议(如http), 相同的端口(如80)，相同的host（如www.example.org)，那么我们就可以认为它们是相同的域。比如http://www.example.org/index.html和http://www.example.org/sub/index.html是同域，而http://www.example.org, https://www.example.org, http://www.example.org:8080, http://sub.example.org中的任何两个都将构成跨域。同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的HTML文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。
                    </p>
                    <p>
                        受到同源策略的影响，跨域资源共享就会受到制约。但是随着人们的实践和浏览器的进步，目前在跨域请求的技巧上，有很多宝贵经验的沉淀和积累。这里我把跨域资源共享分成两种，一种是单向的数据请求，还有一种是双向的消息通信。接下来我将罗列出常见的一些跨域方式，以下跨域实例的源代码可以从这里获得。
                    </p> <b>单向跨域</b>
                    <b>JSONP</b>
                    <p>
                        JSONP (JSON with Padding)是一个简单高效的跨域方式，HTML中的script标签可以加载并执行其他域的JavaScript，于是我们可以通过script标记来动态加载其他域的资源。例如我要从域A的页面pageA加载域B的数据，那么在域B的页面pageB中我以JavaScript的形式声明pageA需要的数据，然后在pageA中用script标签把pageB加载进来，那么pageB中的脚本就会得以执行。JSONP在此基础上加入了回调函数，pageB加载完之后会执行pageA中定义的函数，所需要的数据会以参数的形式传递给该函数。JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。
                    </p>

                    <b>Flash URLLoader</b>
                    <p>
                        Flash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。当跨域访问资源时，例如从域www.a.com请求域www.b.com上的数据，我们可以借助Flash来发送HTTP请求。首先，修改域www.b.com上的crossdomain.xml(一般存放在根目录，如果没有需要手动创建) ，把www.a.com加入到白名单。其次，通过Flash URLLoader发送HTTP请求，最后，通过Flash API把响应结果传递给JavaScript。Flash URLLoader是一种很普遍的跨域解决方案，不过需要支持iOS的话，这个方案就无能为力了。
                    </p>

                    <b>Access Control</b>
                    <p>
                        Access Control是比较超越的跨域方式，目前只在很少的浏览器中得以支持，这些浏览器可以发送一个跨域的HTTP请求（Firefox, Google Chrome等通过XMLHTTPRequest实现，IE8下通过XDomainRequest实现），请求的响应必须包含一个Access-Control-Allow-Origin的HTTP响应头，该响应头声明了请求域的可访问权限。例如www.a.com对www.b.com下的asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头：
                    </p>

                    <b>header("Access-Control-Allow-Origin: http://www.a.com");</b>

                    <b>window.name</b>
                    <p>
                        window对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。那么我们可以在页面A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后，页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。这个方式非常适合单向的数据请求，而且协议简单、安全。不会像JSONP那样不做限制地执行外部脚本。
                    </p>

                    <b>server proxy</b>
                    <p>
                        在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。例如当www.a.com域下的页面需要请求www.b.com下的资源文件asset.txt时，直接发送一个指向www.b.com/asset.txt的ajax请求肯定是会被浏览器阻止。这时，我们在www.a.com下配一个代理，然后把ajax请求绑定到这个代理路径下，例如www.a.com/proxy/, 然后这个代理发送HTTP请求访问www.b.com下的asset.txt，跨域的HTTP请求是在服务器端进行的，客户端并没有产生跨域的ajax请求。这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。
                    </p>

                    <b>双向跨域</b>

                    <b>document.domain</b>
                    <p>
                        通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。同域策略认为域和子域隶属于不同的域，比如www.a.com和sub.a.com是不同的域，这时，我们无法在www.a.com下的页面中调用sub.a.com中定义的JavaScript方法。但是当我们把它们document的domain属性都修改为a.com，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的method来通信了。
                    </p>

                    <b>FIM – Fragment Identitier Messaging</b>
                    <p>
                        不同的域之间，JavaScript只能做很有限的访问和操作，其实我们利用这些有限的访问权限就可以达到跨域通信的目的了。FIM (Fragment Identitier Messaging)就是在这个大前提下被发明的。父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为frag，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带frag，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。FIM的原理就是改变URL的frag部分来进行双向通信。每个window通过改变其他window的location来发送消息，并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，URL在浏览器下有长度限制，这个制约了每次传送的数据量。
                    </p>

                    <b>Flash LocalConnection</b>
                    <p>
                        页面上的双向通信也可以通过Flash来解决，Flash API中有LocalConnection这个类，该类允许两个SWF之间通过进程通信，这时SWF可以播放在独立的Flash Player或者AIR中，也可以嵌在HTML页面或者是PDF中。遵循这个通信原则，我们可以在不同域的HTML页面各自嵌套一个SWF来达到相互传递数据的目的了。SWF通过LocalConnection交换数据是很快的，但是每次的数据量有40kb的大小限制。用这种方式来跨域通信过于复杂，而且需要了2个SWF文件，实用性不强。
                    </p>

                    <b>window.postMessage</b>
                    <p>
                        window.postMessage是HTML5定义的一个很新的方法，这个方法可以很方便地跨window通信。由于它是一个很新的方法，所以在很旧和比较旧的浏览器中都无法使用。
                    </p>
                    <b>Cross Frame</b>
                    <p>
                        Cross Frame是FIM的一个变种，它借助了一个空白的iframe，不会产生多余的浏览器历史记录，也不需要轮询URL的改变，在可用性和性能上都做了很大的改观。它的基本原理大致是这样的，假设在域www.a.com上有页面A.html和一个空白代理页面proxyA.html, 另一个域www.b.com上有个页面B.html和一个空白代理页面proxyB.html，A.html需要向B.html中发送消息时，页面会创建一个隐藏的iframe, iframe的src指向proxyB.html并把message作为URL frag，由于B.html和proxyB.html是同域，所以在iframe加载完成之后，B.html可以获得iframe的URL，然后解析出message，并移除该iframe。当B.html需要向A.html发送消息时，原理一样。Cross Frame是很好的双向通信方式，而且安全高效，但是它在Opera中无法使用，不过在Opera下面我们可以使用更简单的window.postMessage来代替。
                    </p>
                    <b>总结</b>
                    <p>
                        跨域的方法很多，不同的应用场景我们都可以找到一个最合适的解决方案。比如单向的数据请求，我们应该优先选择JSONP或者window.name，双向通信我们采取Cross Frame，在未与数据提供方没有达成通信协议的情况下我们也可以用server proxy的方式来抓取数据。
                    </p>
                    <span style="color:red">只说出了jsonp，后在面试官的提示下说出了iframe的方式。知识面单薄一题击败~</span>
                </p>
                <h5>8.详细说明Ajax工作原理及实现方式？【楚楚街JS研发经理】</h5>
                <hr>
                <p>
                    答：
                    <br>
                    Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。
                    <p>
                        XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。
                        XMLHttpRequest是完全用来向服务器发出一个请求的，它的作用也局限于此，但它的作用是整个ajax实现的关键，因为ajax无非是两个过程，发出请求和响应请求。并且它完全是一种客户端的技术。
                    </p>
                    <span style="color:red">当时的回答是非常凌乱的，说出了Ajax如何创建和发起，没有着重对Ajax原理进行描述，事后赶脚回答是跑题的...</span>
                </p>
                <h5>9.闭包的应用场景有哪些？【楚楚街JS研发经理】</h5>
                <hr>
                <p>
                    <br>
                    1.使用闭包代替全局变量
                    <br>
                    2.函数外或在其他函数中访问某一函数内部的参数
                    <br>
                    3.在函数执行之前为要执行的函数提供具体参数
                    <br>
                    4.在函数执行之前为函数提供只有在函数执行或引用时才能知道的具体参数
                    <br>
                    5.为节点循环绑定click事件，在事件函数中使用当次循环的值或节点，而不是最后一次循环的值或节点
                    <br>
                    6.暂停执行
                    <br>
                    7.包装相关功能
                    <br>
                    <span style="color:red">此问题回答不全面，回答了减少变量污染和包装功能。</span>
                </p>
                <h5 id="antgroup">10.函数中的arguments是什么？他有哪些属性或方法？【蚂蚁金服-资深H5前端开发工程师】</h5>
                <hr>
                <p>
                    答：是一个Arguments对象，是一个类似数组的对象。callee 属性是 arguments 对象的一个成员，仅当相关函数正在执行时才可用。callee 属性的初始值就是正被执行的 Function 对象，这允许匿名的递归函数。其他属性和方法和数组类似，
                    <br>
                    <span style="color:red">
                        电话面试回答时，想当然的回答了Array，后Google发现答错。阿里面试同学之前问的了一些CSS的问题感觉还OK，JS问了很多题，这题败了之后，就开始聊公司和家离的远是不是不方便...是否能接受严重的加班情况...云云...当时基本确定被PASS，虽然果断回答可以接受，但不久还是收到了被拒的阿里邮件。
                    </span>
                </p>
                <h5 id="alimama">11.原生JSAPI考查，使用原生JSAPI创建元素追加，插入等。【阿里妈妈-前端开发专家】</h5>
                <hr>
                <p>
                    答：
                    <pre>
    var header1 = document.getElementById("header"); 
    var p = document.createElement("p"); // 创建一个元素节点 
    insertAfter(p,header1); // 因为js没有直接追加到指定元素后面的方法 所以要自己创建一个方法 
    function insertAfter( newElement, targetElement ){ // newElement是要追加的元素 targetElement 是指定元素的位置 
    var parent = targetElement.parentNode; // 找到指定元素的父节点 
    if( parent.lastChild == targetElement ){ // 判断指定元素的是否是节点中的最后一个位置 如果是的话就直接使用appendChild方法 
            parent.appendChild( newElement, targetElement ); 
        }else{ 
            parent.insertBefore( newElement, targetElement.nextSibling ); 
        }; 
    }; 
                    </pre>
                    <br>
                    <span style="color:red">在回答这个问题时原生API对象函数名有说错的。可以查着API写，面试考查...败~~</span>
                </p>
                <h5>11.自己实现一个JQuery的jsonp。【阿里妈妈-前端开发专家】</h5>
                <hr>
                <p>
                    <pre>
var JSONP = {
    // 获取当前时间戳
    now: function() {
        return (new Date()).getTime();
    },
    
    // 获取16位随机数
    rand: function() {
        return Math.random().toString().substr(2);
    },
    
    // 删除节点元素
    removeElem: function(elem) {
        var parent = elem.parentNode;
        if(parent && parent.nodeType !== 11) {
            parent.removeChild(elem);
        }
    },
    
    // url组装
    parseData: function(data) {
        var ret = "";
        if(typeof data === "string") {
            ret = data;
        }
        else if(typeof data === "object") {
            for(var key in data) {
                ret += "&" + key + "=" + encodeURIComponent(data[key]);
            }
        }
        // 加个时间戳，防止缓存
        ret += "&_time=" + this.now();
        ret = ret.substr(1);
        return ret;
    },
    
    getJSON: function(url, data, func) {
        // 函数名称
        var name;
        
        // 拼装url
        url = url + (url.indexOf("?") === -1 ? "?" : "&") + this.parseData(data);
        
        // 检测callback的函数名是否已经定义
        var match = /callback=(\w+)/.exec(url);
        if(match && match[1]) {
            name = match[1];
        } else {
            // 如果未定义函数名的话随机成一个函数名
            // 随机生成的函数名通过时间戳拼16位随机数的方式，重名的概率基本为0
            // 如:jsonp_1355750852040_8260732076596469
            name = "jsonp_" + this.now() + '_' + this.rand();
            // 把callback中的?替换成函数名
            url = url.replace("callback=?", "callback="+name);
            // 处理?被encode的情况
            url = url.replace("callback=%3F", "callback="+name);
        }
        
        // 创建一个script元素
        var script = document.createElement("script");
        script.type = "text/javascript";
        // 设置要远程的url
        script.src = url;
        // 设置id，为了后面可以删除这个元素
        script.id = "id_" + name;
        
        // 把传进来的函数重新组装，并把它设置为全局函数，远程就是调用这个函数
        window[name] = function(json) {
            // 执行这个函数后，要销毁这个函数
            window[name] = undefined;
            // 获取这个script的元素
            var elem = document.getElementById("id_" + name);
            // 删除head里面插入的script，这三步都是为了不影响污染整个DOM啊
            JSONP.removeElem(elem);
            // 执行传入的的函数
            func(json);
        };
        
        // 在head里面插入script元素
        var head = document.getElementsByTagName("head");
        if(head && head[0]) {
            head[0].appendChild(script);
        }
    }
};
</pre>
                    <p>实现过程基本写在注释里啦，自己看。调用的方法跟jQuery基本一样。如：</p>
                    <pre>
var data = {
            from: "北京",
            count: 27,
            output: "json",
            callback: "?"
        }
JSONP.getJSON("http://api.qunar.com/cdnWebservices.jcp", data, function(json) {console.log(json)});
</pre>
                    当然要这么写也行：
                    <pre>
JSONP.getJSON("http://api.qunar.com/cdnWebservices.jcp?from=北京&count=27&output=json&callback=?", null, function(json) {console.log(json)});
</pre>
                    至于服务端的实现，那就比较简单了，以php为例：
                    <pre>
$callback = !empty($_GET['callback']) ? $_GET['callback'] : 'callback';
echo $callback.'( .json_encode( $data ).')';
</pre>
                    好了，写完了。
                    <br>
                    <span style="color:red">面试时回答：不会￣□￣｜｜</span>
                </p>
                <hr>
                <h3>
                    以上是对这几次失败面试的总结,总的来说大一点的公司喜欢问一些基础，笔试会让手写排序、去重，小公司去了几家喜欢问xxx网站有这样一个东西如何实现，一般来说说出轮廓即可过关。而稍大的公司更注重知识面是否全、广；基础知识是否扎实。总的来说，还需要继续学习，继续准备!<br>2016加油~~
                </h3>
            </div>
        </div>
    </div>
    <script src="./static/jquery/jquery.min.js"></script>
    <script src="./static/bootstrap/js/bootstrap.min.js"></script>
    <script type="text/javascript">
        $(".nav-item").click(function(){
            $(".nav-item").removeClass('active');
            $(this).addClass('active');
        });
    </script>
</body>

</html>